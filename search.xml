<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3063-dynamic-resource-allocation-kep</title>
    <url>/2022/07/06/3063-dynamic-resource-allocation-kep/</url>
    <content><![CDATA[<h3 id="当前device-plugin方式的局限："><a href="#当前device-plugin方式的局限：" class="headerlink" title="当前device plugin方式的局限："></a>当前device plugin方式的局限：</h3><ol>
<li>设备初始化：当前device plugin没有想过配置可以指定设置初始化的一些配置，例如FPGA设备可能需要在program启动之前 reconfigured or reprogrammed，当前device plugin是不能指定设备的一些属性的。</li>
<li>设备cleanup：当前device plugin未提供通用机制在workload介绍时能清理device上的一些数据，或者对设备进行下电操作等。</li>
<li>部分分配：当前device plugin只支持整数分配，不支持部分分配。举个栗子：新型的GPU有MIG模式，支持把GPU划分为一系列mini-GPU（就是MIG devices）,可以给每个MIG GPU指定不同的memory和计算资源，可以根据应用动态划分MIG device。当前的device plugin机制的话，无法做到动态划分，必须是提前划分好以后，通过device plugin上报给kubelet，kubelet根据提前划分好的MIG device分配给应用。</li>
<li>optional allocation: 有时对于device的需求是soft，如果device 存在并可分配，则分配，类似gpu或者一些crypto-offload engines，如果他们不可用的话，workloads可以使用CPU做替代。</li>
<li>fabric devices: 当前device plugin API是给node-local资源设置的，对于一些 network-attached resource来说并没有单个节点的资源限制。</li>
</ol>
<h3 id="当前方案流程"><a href="#当前方案流程" class="headerlink" title="当前方案流程"></a>当前方案流程</h3><h4 id="是用persistent-resourceclaim流程"><a href="#是用persistent-resourceclaim流程" class="headerlink" title="是用persistent resourceclaim流程"></a>是用persistent resourceclaim流程</h4><p><img src="/2022/07/06/3063-dynamic-resource-allocation-kep/persistent.jpg"></p>
<p>使用inline resouceclaim流程</p>
<p><img src="/2022/07/06/3063-dynamic-resource-allocation-kep/inline.jpg"></p>
<p>涉及整个调度过程过于复杂。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sync.Mutex源码分析</title>
    <url>/2022/07/12/golang-sync-Mutex/</url>
    <content><![CDATA[<p>基于golang 版本 1.17</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Mutex结构体定义可知消耗8个字节</p>
<p>其中state表示状态，如下图所示，</p>
<p><img src="/2022/07/12/golang-sync-Mutex/syncmux.jpg"></p>
<ul>
<li>state的第0位表示的mutexLocked，表示mutex是否被加锁，加锁时置1</li>
<li>state的第1位表示的mutexWoken，表示mutex是否被唤醒，唤醒时置1</li>
<li>state的第2位表示的mutexStarving，表示mutex是否处于饥饿模式，饥饿时置1</li>
<li>state其他位是标识等待这个mutex的goroutines的数量。</li>
</ul>
<p>sema是用于控制锁状态的信号量，其实会映射到semtable中的某个semaroot，持有一棵 地址各不相同的 sudog(s.elem) 的平衡树，所有的等锁的goroutines都会加到这个双向链表中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutex fairness.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line"><span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line"><span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line"><span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line"><span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line"><span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line"><span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line"><span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line"><span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line"><span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line"><span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line"><span class="comment">// the tail of the wait queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line"><span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line"><span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line"><span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line"><span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br></pre></td></tr></table></figure>

<p>上面是作者在代码中的注释，阐述了Mutex的Fairness。Mutex提供2个模式，一个是正常模式，一个是饥饿模式。</p>
<ul>
<li>正常模式：wait goroutines是以FIFO来排队。当一个goroutines被唤醒的时候，他可能还没获取锁，而此时有一个新的goroutines，因为他已经占用了CPU，有大的概率会获取到锁。在这种模式下会把这个goroutines加到队首，防止长期获取不到锁。如果一个goroutines超过1ms未获取到锁，则切换到饥饿模式。</li>
<li>在饥饿模式下，在调用Unlock的时候会直接将锁交给队首的goroutines.新的goroutines在调用unlock的时候出现，就不要进去自旋模式了，这是是获取不到锁的，所以讲自己加入到队尾。</li>
</ul>
<p>当goroutines获取到锁，查看自己是否是队列中最后一个元素，或者他等待的时间少于1ms，则切换到正常模式。</p>
<p>对于goroutines获取锁来说，正常模式的性能会更好，当时饥饿模式是为了解决一些长尾问题。</p>
<p>在goroutine能否自旋等锁，当前判断条件：</p>
<ul>
<li><p>在普通模式下才能进去自旋</p>
</li>
<li><p>只有在多核机器上运行并且GOMAXPROCS&gt;1</p>
</li>
<li><p>当前机器上至少存在一个正在运行的处理器 P 并且本地运行队列为空；</p>
</li>
<li><p>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Active spinning for sync.Mutex.</span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// sync.Mutex is cooperative, so we are conservative with spinning.</span></span><br><span class="line">	<span class="comment">// Spin only few times and only if running on a multicore machine and</span></span><br><span class="line">	<span class="comment">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</span></span><br><span class="line">	<span class="comment">// As opposed to runtime mutex we don&#x27;t do passive spinning here,</span></span><br><span class="line">	<span class="comment">// because there can be work on global runq or on other Ps.</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋操作是优化了解决阻塞-&gt;唤醒-&gt;抢占锁过程，这个前提是持有锁的任务都是短时任务，这里进行自旋的话，期望在短时内获取到锁，减少上下文切换。</p>
<p>这里的自旋是做30次的PAUSE指令，只消耗CPU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">	MOVL	cycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$1, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>首先我们通过下图来看下正常模式的流程。</p>
<p>当前G0当前持有锁，当前有3个goroutines在等待锁，分别是g3,g4,g5都等待队列中，按照FIFO原则。</p>
<p>如果此时G1新进来去获取锁，G1在正常模式下会自旋等锁，如果超过了自旋的次数或者不满足自旋要求时，会将g1加到等待队列的尾部，等待Unlock唤醒。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/normal-lock.jpg"></p>
<p><img src="/2022/07/12/golang-sync-Mutex/spin-timeout.jpg"></p>
<p>如果此时G0完成了工作，调用Unlock，此时如果等待队列中不存在等待的goroutines，或者说已经有一个goroutines已经被唤醒，或者已经有goroutines获取到锁的话，就不会去唤醒任何goroutines。</p>
<ul>
<li><p>此时G0会从唤醒等待队列队首的goroutines,如下图，如果g1还处于自旋状态的话，此时mutexWoken位是置1的，所以G0此时不会唤醒任何的队列中的goroutines.</p>
</li>
<li><p>如果此时g1退出自旋状态，将mutexWoken置0，那么此时G0会从唤醒等待队列队首的goroutines,g3会加入到p0.runnext,如下图，最终获取到锁，如果在调度过程中有其他新的goroutines进去，可能提前获取到锁的话，g3会加入到队列的队首，等待下次唤醒。</p>
</li>
</ul>
<p><img src="/2022/07/12/golang-sync-Mutex/normal-unlock.jpg"></p>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>首先我们通过下图来看下饥饿模式的流程。</p>
<p>当前G0当前持有锁，当前有3个goroutines在等待锁，分别是g3,g4,g5都等待队列中，按照FIFO原则。</p>
<p>如果此时G1新进来去获取锁，G1在饥饿模式下不会进入自旋，会按照FIFO的原则直接将goroutines放到队列中等待。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/starving-lock.jpg"></p>
<p>此时G0完成了工作，调用Unlock，此时G0会从唤醒等待队列队首的goroutines,如下图，会将g3唤醒，放到p的runnext上，P0下一次调度执行该goroutines,与正常模式不同的是，此时G0会调用goyeild,会让出时间片，将自己放入到P0本地runq的队尾，等待下次调度，那么由于G3在p0 nextq上，g3就会马上获得时间片，获取到锁。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/starving-unlock.jpg"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">		<span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">// //判断是否有锁并且不处于饥饿模式，并且runtime满足自旋的要求,满足自旋的要求的话，进去自旋状态。直到获取到锁，或者不满足自旋的转态。</span></span><br><span class="line">        <span class="comment">// old&amp;(mutexLocked|mutexStarving) == mutexLocked 表示是否处于锁定并且非饥饿状态</span></span><br><span class="line">        <span class="comment">// runtime_canSpin返回的是runtime是否能自旋，条件如上介绍的</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">// old&amp;mutexWoken == 0标明在正常模式下没有其他正在唤醒的goroutines</span></span><br><span class="line">            <span class="comment">// old&gt;&gt;mutexWaiterShift != 0 标明等待队列中有其他的goroutines在等待锁。</span></span><br><span class="line">            <span class="comment">// 这里将state mutexWoken置为1,是为了防止再Unlock的时候去唤醒其他的阻塞的协程。</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 计算当前互斥锁的状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">		<span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">// 如果老的状态处于非饥饿状态的话，给new加锁</span></span><br><span class="line">        <span class="comment">// 如果处于饥饿状态的话，新到来的goroutines需要排队。</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果老的状态处于锁定或者饥饿模式下，则将等待者数量+1</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">		<span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">// 如果老的状态在锁定状态，并且当前处于饥饿模式的话，则要切换状态到饥饿模式。</span></span><br><span class="line">        <span class="comment">// 如果当前处于未锁定的状态的话，</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 需要将mutexWoken置为0，这样使得unlock的时候可以去唤醒goroutines</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果老的状态是未加锁，并且不处于饥饿状态，获取到锁直接退出。</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            <span class="comment">// 如果这里的waitStartTime不为0的话，标明这个goroutines已经等待过了，需要放到队列头。</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 阻塞等待，如果等待过的goroutines加到队头，新的goroutines的话加入到队尾等待。</span></span><br><span class="line">            <span class="comment">// runtime_SemacquireMutex这个会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回</span></span><br><span class="line">			runtime_SemacquireMutex这个会(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 当前goroutines已经饥饿了状态不变化，如果等待的时间超过了1ms的话，切换成饥饿状态。</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">            <span class="comment">// 如果当前处于饥饿状态的话，就说明当前的goroutines是被唤醒的，锁是处于释放状态。</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 将等待的goroutines - 1</span></span><br><span class="line">				delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 如果当前不处于饥饿模式，或者只剩下一个goroutines在等待了，也退出饥饿模式。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line">		<span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// unlock一个为加锁的Mutex,panic</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line">			<span class="comment">// So get off the way.</span></span><br><span class="line">            <span class="comment">// old&gt;&gt;mutexWaiterShift == 0 判断锁上是否还有等待的goroutine</span></span><br><span class="line">            <span class="comment">// old&amp;(mutexLocked|mutexWoken|mutexStarving) 表示说已经有goroutines获取锁，或者说被唤醒,或者切换到饥饿模式了，这样直接返回，不需要唤醒任何goroutines</span></span><br><span class="line">            <span class="comment">// 因为饥饿模式下我们将锁直接交给下一个goroutines，不在这个分支里。</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line">		<span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line">		<span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">        <span class="comment">// handoff的做法是release函数将waiter加到当前P的runnext中，然后通过调用goyeild立即让出时间片，所以next waiter能马上运行，获取到锁。goyield 类似于 Gosched，但它会发出一个“抢占式”跟踪事件，更重要的是，将当前 G 放在本地 runq 而不是全局 runq 上。我们只在饥饿状态下（handoff=true）这样做，因为在非饥饿情况下，新的goroutines可能会在我们让出调度时获取信号量，这将是浪费的。相反，我们等待进入饥饿状态，然后开始直接切换票和 P。</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>sync-rwmutex</title>
    <url>/2022/07/19/sync-rwmutex/</url>
    <content><![CDATA[<p>基于golang 1.17版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A RWMutex is a reader/writer mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The lock can be held by an arbitrary number of readers or a single writer.</span></span><br><span class="line"><span class="comment">// The zero value for a RWMutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A RWMutex must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a goroutine holds a RWMutex for reading and another goroutine might</span></span><br><span class="line"><span class="comment">// call Lock, no goroutine should expect to be able to acquire a read lock</span></span><br><span class="line"><span class="comment">// until the initial read lock is released. In particular, this prohibits</span></span><br><span class="line"><span class="comment">// recursive read locking. This is to ensure that the lock eventually becomes</span></span><br><span class="line"><span class="comment">// available; a blocked Lock call excludes new readers from acquiring the</span></span><br><span class="line"><span class="comment">// lock.</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">	readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">	readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">	readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写锁是更细粒度的锁。通过RWMutex的结构体可以知道该锁消耗24字节。</p>
<ul>
<li>w: 复用了互斥锁的能理，用来表示是否有阻塞的writer</li>
<li>writerSem: writers等待readers完成的信号量</li>
<li>readerSem; readers等待writers完成的信号量</li>
<li>readerCount: 已获取了读锁的数量，当writer获取到锁时，该值&lt;0</li>
<li>readerWait: 获取到写锁时，此时已获取的读锁的数量。</li>
</ul>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>加写锁可以分为2种情况</p>
<ul>
<li>是否有goroutines获取了写锁：如下图左边所示，如果g0已经获取了写锁，那么g1再去获取写锁的话，就呼阻塞在w互斥锁上，等待g1释放互斥锁后，再执行后续操作。</li>
<li>是否有goroutines获取了读锁的话：如下图右边所示，如果g1已经获取了读锁，那么g1再去获取写锁时，由于当前无写锁，g1获取了w互斥锁后，会将利用原子操作将readCount - maxReaders，将readCount置为负数的话，主要是为阻塞后续的加读锁操作，防止写锁饿死。也就说只有有写锁获取了w互斥锁后，尽量阻塞其他的读锁。然后将readerWait值置为当前已获取读锁的goroutines的数量，如果!&#x3D;0的话，则将自己阻塞在writeSem上，等所有读锁释放了锁之后唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-lock.jpg"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    <span class="comment">// 阻塞其他的writers,保证只有一个writer</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    <span class="comment">// 这里讲readerCount-rwmutexMaxReaders，其实将readerCount置为负数了，标明有一个pending的writer.</span></span><br><span class="line">    <span class="comment">// 这里也就是获取了写锁之后，会阻塞读锁的获取。</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">    <span class="comment">// 这里r是标明当前已经获取到读锁的goroutines的数量，如果这里不为0的话，设置readerWait，说明有未释放的读锁数量，并将自己挂在writeSem信号量上休眠，等待所有读锁释放后，唤醒。</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>写锁的释放流程很简单</p>
<ol>
<li>第一步先讲readerCount+maxReaders，标明没有正在执行的writer了，这样可以不阻塞后续的读锁。</li>
<li>如果在readerSem上有因为写操作阻塞的读操作的话，唤醒这个信号量上的所有的goroutines.</li>
<li>最后释放互斥锁， 这样下一个写操作可以获取到该互斥锁。这里先唤醒reader再释放写锁，可以保证读操作不会被连续的写操作饿死。</li>
</ol>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-unlock.jpg"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks rw for writing. It is a run-time error if rw is</span></span><br><span class="line"><span class="comment">// not locked for writing on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As with Mutexes, a locked RWMutex is not associated with a particular</span></span><br><span class="line"><span class="comment">// goroutine. One goroutine may RLock (Lock) a RWMutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to RUnlock (Unlock) it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    <span class="comment">// 把readerCount + rwmutexMaxReaders，将readerCount变为整数，标明没有正在执行的writer了。</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// 如果Unlocok一个没有Lock的RwMutex会panic</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">// 如果存在因为writer阻塞的reader的话，将所有尝试获取读锁的goroutine唤醒</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">    <span class="comment">// 释放写锁，这样下一个写锁可以尝试获取。</span></span><br><span class="line">    <span class="comment">// 这里先唤醒reader再释放写锁，可以保证读操作不会被连续的写操作饿死。</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><h4 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h4><ul>
<li>获取读锁的流程比较简单，如果在没有获取写锁的goroutines，仅仅将readerCount +1</li>
<li>如果有goroutines已经获取了写锁的话也就是readerCount  &lt;0,此时将自己阻塞在readerSem信号量上，等写锁释放后将goroutines唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-rlock.jpg"></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RLock locks rw for reading.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It should not be used for recursive read locking; a blocked Lock</span></span><br><span class="line"><span class="comment">// call excludes new readers from acquiring the lock. See the</span></span><br><span class="line"><span class="comment">// documentation on the RWMutex type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果readerCount &lt;0 ，说明有goroutines应获取了写锁，所以此时将goroutines挂到readerSem信号量上，休眠，待写锁释放后，唤醒。</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h3><h4 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h4><ul>
<li>如果没有任何写锁相关的操作的话，Runlock只是将readerCount-1.</li>
<li>如果此时readerCount &lt;0，标明当前有goroutines已经获取了互斥锁，等待所有读操作释放锁后，获取写锁。将readerWait -1， 标明的是当前还有多少个goroutines持有读锁，如果此时readerWait &#x3D;&#x3D; 0，说明所有的读锁已经释放，则将writerSem上阻塞的goroutine唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-runlock.jpg"></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RUnlock undoes a single RLock call;</span></span><br><span class="line"><span class="comment">// it does not affect other simultaneous readers.</span></span><br><span class="line"><span class="comment">// It is a run-time error if rw is not locked for reading</span></span><br><span class="line"><span class="comment">// on entry to RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果r&lt;0的话说明有一个获取了写锁但在等待读锁全部释放的writer.</span></span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="comment">// 每次都减少readerWait的数量，等到readerWait ==0的时候表明所有的获取读锁的goroutines都释放了锁，此时可以讲writer唤醒，执行写操作。</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
